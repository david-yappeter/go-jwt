package service

import (
	"context"
	"fmt"
	config "myapp/config"
	model "myapp/graph/model"
	tools "myapp/tools"
)

//Generated By github.com/davidyap2002/GormCrudGenerator

//UserCreate Create
func UserCreate(ctx context.Context, input model.NewUser) (*model.User, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	pass, err := tools.HashPassword(input.Password)

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	user := model.User{
		Email:    input.Email,
		Name:     input.Name,
		Password: pass,
	}

	err = db.Table("user").Create(&user).Error

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return &user, nil
}

//UserCreateBatch Create Batch
func UserCreateBatch(ctx context.Context, input []*model.NewUser) ([]*model.User, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	var userBatch []*model.User

	for _, val := range input {
		pass, err := tools.HashPassword(val.Password)

		if err != nil {
			fmt.Println(err)
			return nil, err
		}
		user := model.User{
			Email:    val.Email,
			Name:     val.Name,
			Password: pass,
		}

		userBatch = append(userBatch, &user)
	}

	err := db.Table("user").Create(&userBatch).Error

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return userBatch, nil
}

//UserUpdate Update
func UserUpdate(ctx context.Context, input model.UpdateUser) (*model.User, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	user := model.User{
		Email:    input.Email,
		ID:       input.ID,
		Name:     input.Name,
		Password: input.Password,
	}

	err := db.Table("user").Where("id = ?", input.ID).Updates(map[string]interface{}{

		"email":    input.Email,
		"id":       input.ID,
		"name":     input.Name,
		"password": input.Password,
	}).Error

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return &user, nil
}

//UserDelete Delete
func UserDelete(ctx context.Context, id int) (string, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	err := db.Table("user").Where("id = ?", id).Delete(&model.User{}).Error

	if err != nil {
		fmt.Println(err)
		return "Fail", err
	}

	return "Success", nil
}

//UserGetByID Get By ID
func UserGetByID(ctx context.Context, id int) (*model.User, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	var user model.User

	err := db.Table("user").Where("id = ?", id).First(&user).Error

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return &user, nil
}

//UserGetAll GetAll
func UserGetAll(ctx context.Context) ([]*model.User, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	var user []*model.User

	err := db.Table("user").Find(&user).Error

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return user, nil
}

//UserPagination Pagination
func UserPagination(ctx context.Context, limit int, page int, ascending bool, sortBy string, filter []int) ([]*model.User, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	var user []*model.User

	query := db.Table("user")

	tools.QueryMaker(query, limit, page, ascending, sortBy, filter)
	err := query.Find(&user).Error

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return user, nil
}

//UserTotalDataPagination  Total Data Pagination
func UserTotalDataPagination(ctx context.Context, limit int, page int, ascending bool, sortBy string, filter []int) (int, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	var count int64

	query := db.Table("user")

	tools.QueryMaker(query, limit, page, ascending, sortBy, filter)
	err := query.Count(&count).Error

	if err != nil {
		fmt.Println(err)
		return 0, err
	}

	return int(count), nil
}
